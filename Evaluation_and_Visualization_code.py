# -*- coding: utf-8 -*-
"""Evaluation_File_11_08_3month.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WmMd7eYqcJY9npARLq6rpDMhmtoul4fN
"""

from google.colab import drive
drive.mount('/content/gdrive')

!pip install basemap
!pip install mat73
!pip install efficientnet
!pip install keras.layer.merge
!pip install netCDF4
!pip install tensorflow==2.15.0

import matplotlib.pyplot as plt
import numpy as np
import netCDF4 as nc
import tarfile
import os
import numpy.ma as ma
import pandas as pd
from scipy.interpolate import griddata
###Read file
#import pygrib
from netCDF4 import Dataset
from mpl_toolkits.basemap import Basemap
from mpl_toolkits.axes_grid1 import ImageGrid
import datetime
from pathlib import Path
import scipy.io as io
import mat73
import glob

import numpy as np
#from keras.utils import np_utils
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import Flatten
from keras.layers import Conv2D
from keras.layers import MaxPooling2D
from keras import backend as K

#from keras.utils.generic_utils import get_custom_objects
from keras import initializers, constraints, regularizers, layers
#from keras.preprocessing.image import ImageDataGenerator
from keras.models import Model, load_model
from keras.layers import Input, Dropout, Conv2D,Conv2DTranspose, BatchNormalization, add
from keras.layers import Conv2D, Conv2DTranspose
from keras.layers import Concatenate,concatenate
from keras.layers import MaxPooling2D
from keras import backend as K
from keras.layers import LeakyReLU
from keras.losses import binary_crossentropy
import efficientnet.keras as efn

from keras import metrics
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from keras.optimizers import SGD
from keras.layers import UpSampling2D
import tensorflow as tf
from tensorflow import keras
from numpy import pad
from collections import OrderedDict

from osgeo import gdal, ogr
dataset = gdal.Open(r'/content/gdrive/MyDrive/Colab Notebooks/DEM/DEM_input.tif')
band1 = dataset.GetRasterBand(1)
dem = band1.ReadAsArray()
dem.shape
dem[np.where(dem==32767)]=-99
#dem[np.where(dem<0)]=0
dem =(dem-0)/(np.max(dem)-0)*1
#dem = dem[:256,:256]

"""#Model Setting"""

###EfficientUNetB4
!pip install tensorflow-addons
import tensorflow_addons as tfa
from tensorflow_addons.layers import GroupNormalization
def H(lst, name, use_gn=False):
    norm = BatchNormalization(name=name+'_bn')

    x = concatenate(lst)
    shape_list = list(x.shape)
    num_filters = int(shape_list[-1] / 2)

    x = Conv2D(num_filters, (3, 3), padding='same', name=name)(x)
    x = norm(x)
    x = LeakyReLU(alpha=0.1, name=name+'_activation')(x)

    return x

def U(x, use_gn=False):
    norm = BatchNormalization()

    # Convert shape to list
    shape_list = list(x.shape)
    num_filters = int(shape_list[-1] / 2)

    x = Conv2DTranspose(num_filters, (3, 3), strides=(2, 2), padding='same')(x)
    x = norm(x)
    x = LeakyReLU(alpha=0.1)(x)

    return x

def EfficientUNet(input_shape):
    backbone = efn.EfficientNetB4(
        weights=None,
        include_top=True,
        pooling = 'max',
        input_shape=input_shape
    )

    input = backbone.input
    x00 = backbone.input  # (384,384,2)
    x10 = backbone.get_layer('stem_activation').output  # (128, 256, 4)
    x20 = backbone.get_layer('block2d_add').output  # (64, 128, 32)
    x30 = backbone.get_layer('block3d_add').output  # (32, 64, 56)
    x40 = backbone.get_layer('block5f_add').output  # (16, 32, 160)
    x50 = backbone.get_layer('block7b_add').output  # (8, 16, 448)

    x01 = H([x00, U(x10)], 'X01')
    x11 = H([x10, U(x20)], 'X11')
    x21 = H([x20, U(x30)], 'X21')
    x31 = H([x30, U(x40)], 'X31')
    x41 = H([x40, U(x50)], 'X41')

    x02 = H([x00, x01, U(x11)], 'X02')
    x12 = H([x11, U(x21)], 'X12')
    x22 = H([x21, U(x31)], 'X22')
    x32 = H([x31, U(x41)], 'X32')

    x03 = H([x00, x01, x02, U(x12)], 'X03')
    x13 = H([x12, U(x22)], 'X13')
    x23 = H([x22, U(x32)], 'X23')

    x04 = H([x00, x01, x02, x03, U(x13)], 'X04')
    x14 = H([x13, U(x23)], 'X14')

    x05 = H([x00, x01, x02, x03, x04, U(x14)], 'X05')

    x_out = Concatenate(name='bridge')([x01, x02, x03, x04, x05])
    x_out = Conv2D(1, (3,3), padding="same", name='final_output', activation=tfa.activations.mish)(x_out)
    #x_out = Conv2D(1, (3,3), padding="same", name='final_output', activation='relu')(x_out)

    return Model(inputs=input, outputs=x_out)

model = EfficientUNet((256, 256,1))

model.compile(loss='mse', optimizer=tf.keras.optimizers.Adam(learning_rate=0.001))

"""#Test"""

model_cnn= keras.models.load_model("/content/gdrive/MyDrive/Colab Notebooks/CNN_Efficient_3_17_2023/Model/Modelef_03_22_test5.h5",compile=False)

model_cnn = keras.models.load_model('/content/gdrive/MyDrive/Colab Notebooks/Bias Correction Revision/Models/unet.h5',compile=False)

model_cnn.summary()

model_ef= load_model('/content/gdrive/MyDrive/Colab Notebooks/CNN_Efficient_3_17_2023/Model_for_paper/Modelef_09_25_3hour_ver1.h5',compile=False)

model_ef = keras.models.load_model('/content/gdrive/MyDrive/Colab Notebooks/Bias Correction Revision/Models/ef_nodem.h5',compile=False)

model_ef.summary()

model_gan= keras.models.load_model('/content/gdrive/MyDrive/Colab Notebooks/CNN_Efficient_3_17_2023/Model_for_paper/ModelGAN_3hour_09_25_ver1.h5',compile=False)

model_gan_daily= keras.models.load_model("/content/gdrive/MyDrive/Colab Notebooks/CNN_Efficient_3_17_2023/Model/ModelGAN_04_10_test3.h5",compile=False)

model_daily = keras.models.load_model("/content/gdrive/MyDrive/Colab Notebooks/CNN_Efficient_3_17_2023/Model_for_paper/Modelef_09_25_daily_ver1.h5",compile=False)

# model_weights = load_model.get_weights()
# model.set_weights(model_weights)

"""Test Jan 2021"""

path = "/content/gdrive/MyDrive/Colab Notebooks/PDIR_3hour/"
dir_list = os.listdir(path)
from tkinter import Tcl
dir_list=Tcl().call('lsort', '-dict', dir_list)
dir_list

fn = glob.glob(path + '*202101.nc')[0]
fn

data1 = Dataset(fn)
precip =data1.variables['precip'][:]
xtest1=np.zeros([precip.shape[0],384,384])
for i in range(precip.shape[0]):
    xtest1[i]=precip[i][11:395,0:384]
lats = data1.variables['lat'][:]
lons = data1.variables['lon'][:]

fn2= '/content/gdrive/MyDrive/Colab Notebooks/ST4_hourly/st4_hourly_2021_jan.mat'
mat = mat73.loadmat(fn2)['st4_hourly']
ytest1=np.zeros([mat.shape[2],384,384])
for i in range(mat.shape[2]):
    ytest1[i]=mat[:,:,i]

#x_3hour=np.zeros([int(xtest1.shape[0]/3),384,384])
y_3hour=np.zeros([int(ytest1.shape[0]/3),384,384])
for i in range(int(ytest1.shape[0]/3)):
  #x_3hour[i]= sum(xtest1[i*3:i*3+3,:,:],0)
  y_3hour[i]= sum(ytest1[i*3:i*3+3,:,:],0)

xtest=xtest1
ytest=y_3hour
Xtest= np.zeros([xtest.shape[0],256,256,2])
Ytest= np.zeros([ytest.shape[0],256,256])
for i in range(248):
    a=xtest[i]
    b=ytest[i]
    idx=np.where(a<=-99)
    a[idx]=-0.001
    b[np.where(np.isnan(b))]= 0
    b[idx]=-0.001
    a1=np.stack([a, dem],-1)
    Ytest[i]=b[:256,:256]
    Xtest[i]=a1[:256,:256,:]

ytest=[]
xtest=[]
data=[]
mat=[]

"""Test Winter 2022-2023"""

path = "/content/gdrive/MyDrive/Colab Notebooks/PDIR_3hour/"
dir_list = os.listdir(path)
from tkinter import Tcl
dir_list=Tcl().call('lsort', '-dict', dir_list)
dir_list

print(path + dir_list[1])
print(path + dir_list[2])
print(path + dir_list[3])

data1 = Dataset(path + dir_list[1])
precip =data1.variables['precip'][:]
xtest1=np.zeros([precip.shape[0],384,384])
for i in range(precip.shape[0]):
    xtest1[i]=precip[i][11:395,0:384]
lats = data1.variables['lat'][:]
lons = data1.variables['lon'][:]

data1 = Dataset(path + dir_list[2])
precip =data1.variables['precip'][:]
xtest2=np.zeros([precip.shape[0],384,384])
for i in range(precip.shape[0]):
    xtest2[i]=precip[i][11:395,0:384]

data1 = Dataset(path + dir_list[3])
precip =data1.variables['precip'][:]
xtest3=np.zeros([precip.shape[0],384,384])
for i in range(precip.shape[0]):
    xtest3[i]=precip[i][11:395,0:384]

xtest=np.concatenate([xtest1,xtest2,xtest3])
xtest1,xtest2,xtest3=[],[],[]
xtest.shape

#hourly winter file from month 11-3
fn2= '/content/gdrive/MyDrive/Colab Notebooks/ST4_hourly/st4_hourly_winter_20_21.mat'
mat = mat73.loadmat(fn2)['st4_hourly']
print(mat.shape)
ytest1=np.zeros([mat.shape[2],384,384])
for i in range(mat.shape[2]):
    ytest1[i]=mat[:,:,i]

ytest= ytest1[30*24:30*24+2160]
ytest1=[]
y_3hour=np.zeros([int(ytest.shape[0]/3),384,384])
for i in range(int(ytest.shape[0]/3)):
  y_3hour[i]= sum(ytest[i*3:i*3+3,:,:],0)

y_3hour.shape

select_id=[]
for i in range(y_3hour.shape[0]):
    if np.count_nonzero(np.isnan(y_3hour[i])) < 384*384:
        select_id.append(i)
len(select_id)

# xtest=xtest[select_id]
# y_3hour=y_3hour[select_id]

Xtest1= np.zeros([xtest.shape[0],256,256,2])
Ytest= np.zeros([y_3hour.shape[0],256,256])
for i in range(xtest.shape[0]):
    a=xtest[i]
    b=y_3hour[i]
    idx=np.where(a<=-99)
    a[idx]=-0.001
    b[np.where(np.isnan(b))]= 0
    b[idx]=-0.001
    a1=np.stack([a, dem],-1)
    Ytest[i]=b[:256,:256]
    Xtest1[i]=a1[:256,:256,:]

ytest=[]
xtest=[]
data=[]
mat=[]
print(Xtest1.shape,Ytest.shape)

Xtest=Xtest1[...,0].reshape(Xtest1.shape[0],256,256,1)
Xtest.shape

test1=model_cnn.predict(Xtest1,batch_size=4)
test1=test1.reshape(test1.shape[0],256,256).astype('float64')

test2=model_ef.predict(Xtest,batch_size=4)
test2=test2.reshape(test2.shape[0],256,256).astype('float64')

BATCH_SIZE=1
Ytest = np.reshape(Ytest,[Ytest.shape[0], 256, 256,1])
test=np.concatenate((Xtest1,Ytest), axis=-1)
def load(input):

  input_image = tf.convert_to_tensor(input[...,0:2])
  real_image = tf.convert_to_tensor(tf.reshape(input[...,2],[256,256,1]))

  # Convert both images to float32 tensors
  input_image = tf.cast(input_image, tf.float32)
  real_image = tf.cast(real_image, tf.float32)

  return input_image, real_image

## Build an input pipeline with `tf.data`
def load_image_train(image_file):
  input_image, real_image = load(image_file)

  return input_image, real_image

def load_image_test(image_file):
  input_image, real_image = load(image_file)
  return input_image, real_image

## Build an input pipeline with `tf.data`
test_dataset = tf.data.Dataset.from_tensor_slices(test)
test_dataset = test_dataset.map(load_image_test)
test_dataset = test_dataset.batch(BATCH_SIZE)
test=[]

test3=np.zeros([Xtest.shape[0],256,256])
i=0
for inp,tar in test_dataset:
  prediction = model_gan(inp,training=True)
  test3[i]=np.array(prediction[0,...,0])
  i+=1

# select_id=[]
# for i in range(Ytest.shape[0]):
#     if np.count_nonzero(Ytest[i]>0.1) >= 0.3*256*256:
#         select_id.append(i)
# select_id

#Quantile
X1=np.load(r'/content/gdrive/MyDrive/Colab Notebooks/CNN_Efficient_3_17_2023/Model input/X_3hour_256.npy')
Y1=np.load(r'/content/gdrive/MyDrive/Colab Notebooks/CNN_Efficient_3_17_2023/Model input/Y_3hour_256.npy')
print(X1.shape,Y1.shape)
PDIR= X1[...,0]
quantiles =[0, 30, 50, 65, 75, 82, 87, 91, 94, 95, 97.13, 98.02, 98.64, 99.08, 99.39, 99.61, 99.76, 99.87, 99.95, 100]
quantiles = np.array(quantiles) / 100
# Initialize arrays to store quantile values for X and Y
quantiles_X = np.zeros((20, 256, 256))
quantiles_Y = np.zeros((20, 256, 256))
for i in range(256):
    for j in range(256):
        quantiles_X[:, i, j] = np.quantile(PDIR[:, i, j], quantiles)
        quantiles_Y[:, i, j] = np.quantile(Y1[:, i, j], quantiles)

def apply_mapping_function(future_satellite_estimate, satellite_quantiles, observed_quantiles):
    # Create a mask indicating where interpolation should be performed (i.e., where future_satellite_estimate is non-zero)
    non_zero_mask = future_satellite_estimate > 0

    # Get the indices where the mask is True
    lat_indices, lon_indices = np.where(non_zero_mask)
    corrected_estimate = np.copy(future_satellite_estimate)

    # Interpolate along the first axis (quantiles) for each non-zero pixel
    for lat, lon in zip(lat_indices, lon_indices):
        # Extract quantile arrays for the current pixel
        sat_quantiles = satellite_quantiles[:, lat, lon]
        obs_quantiles = observed_quantiles[:, lat, lon]
        # Perform interpolation
        corrected_estimate[lat, lon] = np.interp(future_satellite_estimate[lat, lon], sat_quantiles, obs_quantiles, left=obs_quantiles[0], right=obs_quantiles[-1])

    return corrected_estimate
test0 = np.zeros([Xtest.shape[0],256,256])
for i in range(Xtest.shape[0]):
  test0[i] = apply_mapping_function(Xtest[i,...,0],quantiles_X, quantiles_Y)

Ytest = np.reshape(Ytest,[Ytest.shape[0], 256, 256])
nan_indx1 = np.where(Ytest[100]==-0.001)
count_indx1= len(nan_indx1[0])
#Adjust prediction
test1[np.where(test1<0)]=0
test2[np.where(test2<0)]=0
test3[np.where(test3<0)]=0
for i in range(Xtest.shape[0]):
  test1[i][nan_indx1]=-0.001
  test2[i][nan_indx1]=-0.001
  test3[i][nan_indx1]=-0.001

lats=lats[11:267]
lons=lons[0:256]
mp= Basemap(projection = 'merc',
             llcrnrlon =lons[0],
             llcrnrlat = lats[255],
             urcrnrlon = lons[255],
             urcrnrlat = lats[0],
             resolution = 'i')
lon, lat = np.meshgrid(lons, lats)
x,y = mp(lon, lat)

print(lats[0],lats[255],lons[0],lons[255])

##Display images
for i in range(50):
  display_list = [Xtest[i+248][:,:,0], test1[i+248],test2[i+248],test3[i+248], Ytest[i+248]]
  title = ['Input Image', 'Unet','Efficient','GAN', 'Ground Truth']

  plt.figure(figsize=(28,4))
  for j in range(5):
    plt.subplot(1, 5, j+1)
    plt.title(title[j],fontsize=15)
    plt.imshow(display_list[j],cmap='jet')
    plt.clim(0,4)
    if j==4:
      plt.colorbar()


  plt.show()

##Show total precipitation

display_list = [np.sum(Xtest[:,:,:,0],axis=0), np.sum(test1,axis=0),np.sum(test2,axis=0),np.sum(test3,axis=0), np.sum(Ytest,axis=0)]
title = ['Input Image', 'Unet','Efficient','GAN', 'Ground Truth']

plt.figure(figsize=(28,4))
for i in range(5):
  plt.subplot(1, 5, i+1)
  plt.title(title[i],fontsize=20)
  mp.pcolor(x, y, display_list[i], cmap = 'jet')
  mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.2)#,fontsize=14,labels=[1,0,0,0])
  mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.2)#,fontsize=14,labels=[0,0,0,1])
  mp.drawcoastlines()
  mp.drawstates()
  mp.drawcountries()

  # cbar=plt.colorbar()
  # cbar.ax.tick_params(labelsize=14)
  plt.clim(0,1000)
  if i==4:
    plt.colorbar()


plt.show()

plt.figure(figsize=(16,10))
i=3
plt.title(title[i],fontsize=20)
mp.pcolor(x, y, display_list[i], cmap = 'jet')
mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.2)#,fontsize=14,labels=[1,0,0,0])
mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.2)#,fontsize=14,labels=[0,0,0,1])
mp.drawcoastlines()
mp.drawstates()
mp.drawcountries()

cbar=plt.colorbar()
cbar.ax.tick_params(labelsize=14)
plt.clim(0,1000)

[289.0761849 , 173.13584063, 199.47545223, 158.45898731, 204.6942964 , 246.67151474]

"""#Evaluation


"""

##
cm1=np.zeros([Ytest.shape[0],1])
cm2=np.zeros([Ytest.shape[0],1])
cm3=np.zeros([Ytest.shape[0],1])
cm4=np.zeros([Ytest.shape[0],1])
cm5=np.zeros([Ytest.shape[0],1])
cm6=np.zeros([Ytest.shape[0],1])

for i in range(Ytest.shape[0]):
  cm1[i] = np.corrcoef(Xtest[i,:,:,0].flatten(),Ytest[i].flatten())[0,1]
  cm2[i] = np.sqrt(mean_squared_error(Xtest[i,:,:,0].flatten(),Ytest[i].flatten()))
  cm3[i] = np.mean(np.abs(Xtest[i,:,:,0].flatten()-Ytest[i].flatten()))
  cm4[i] = np.corrcoef(test2[i].flatten(),Ytest[i].flatten())[0,1]
  cm5[i] = np.sqrt(mean_squared_error(test2[i].flatten(),Ytest[i].flatten()))
  cm6[i] = np.mean(np.abs(test2[i].flatten()-Ytest[i].flatten()))

cm1 = np.ma.masked_where(np.isnan(cm1), cm1)
cm4 = np.ma.masked_where(np.isnan(cm4), cm4)

print(np.mean(cm1))
print(np.mean(cm2))
print(np.mean(cm3))
print(np.mean(cm4))
print(np.mean(cm5))
print(np.mean(cm6))

#CC, RMSE, MAE

##POD, FAR, CSI

#New figure 09/28/2023
def matrix(a, b):
  m = np.zeros((2, 2), dtype=np.int64)
  m[0, 0] = np.sum(np.logical_and(a == 1, b == 1))
  m[1, 1] = np.sum(np.logical_and(a == 0, b == 0))
  m[0, 1] = np.sum(np.logical_and(a == 0, b == 1))
  m[1, 0] = np.sum(np.logical_and(a == 1, b == 0))
  return m
##
for i in range(Ytest.shape[0]):
  Xtest1[i][nan_indx1]=-0.001
  Ytest[i][nan_indx1]=-0.001
#
cor_fig, rmse_fig , mae_fig, pod_fig, far_fig, csi_fig = np.empty([4,256,256]),np.empty([4,256,256]),np.empty([4,256,256]),np.empty([4,256,256]),np.empty([4,256,256]),np.empty([4,256,256])
a=np.empty((720,256,256), dtype=np.uint8)
b=np.empty((720,256,256), dtype=np.uint8)
c=np.empty((720,256,256), dtype=np.uint8)
list1=[Xtest1[...,0], test1, test2, test3]
##
for l in range(4):
  pred=list1[l]
  threshold =0.1
  a = np.where(pred < threshold, 0, 1)
  b = np.where(Ytest < threshold, 0, 1)
  for i in range(256):
    for j in range(256):
      if Ytest[1,i,j]==-0.001 :
        cor_fig[l,i,j]=np.nan;
        rmse_fig[l,i,j]=np.nan;
        mae_fig[l,i,j]=np.nan;
      else:
        cor_fig[l,i,j]=np.corrcoef(pred[:,i,j],Ytest[:,i,j])[1,0];
        rmse_fig[l,i,j] = np.sqrt(mean_squared_error(pred[:,i,j],Ytest[:,i,j]));
        mae_fig[l,i,j] = np.mean(np.abs(pred[:,i,j]-Ytest[:,i,j]))
    ##
      m=matrix(a[:,i,j],b[:,i,j]);
      if Ytest[1,i,j]==-0.001 or np.sum(m[0,:])==0 or np.sum(m[:,0])==0:
        pod_fig[l,i,j]=np.nan;
        far_fig[l,i,j]=np.nan;
        csi_fig[l,i,j]=np.nan;
      else:
        pod_fig[l,i,j]=m[0,0]/np.sum(m[0,:]);
        far_fig[l,i,j]=m[1,0]/np.sum(m[:,0]);
        csi_fig[l,i,j]=m[0,0]/(np.sum(m[0,:])+m[1,0])
  print(l)

cor_fig = np.ma.masked_where(np.isnan(cor_fig), cor_fig)
rmse_fig = np.ma.masked_where(np.isnan(rmse_fig), rmse_fig)
mae_fig = np.ma.masked_where(np.isnan(mae_fig), mae_fig)
pod_fig = np.ma.masked_where(np.isnan(pod_fig), pod_fig)
far_fig = np.ma.masked_where(np.isnan(far_fig), far_fig)
csi_fig = np.ma.masked_where(np.isnan(csi_fig), csi_fig)

#New figure 09/28/2023
display_list = [cor_fig[2], rmse_fig[2] , mae_fig[2], pod_fig[2], far_fig[2], csi_fig[2]]
title = ['CC', 'RMSE','MAE','POD', 'FAR','CSI']
# cor_fig[nan_indx1]=np.nan
# rmse_fig[nan_indx1]=np.nan
# mae_fig[nan_indx1]=np.nan
plt.figure(figsize=(32,6))
for i in range(6):
  plt.subplot(1, 6, i+1)
  plt.title(title[i],fontsize=24)
  mp.pcolor(x, y, display_list[i], cmap = 'jet')
  mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.2)#,fontsize=14,labels=[1,0,0,0])
  mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.2)#,fontsize=14,labels=[0,0,0,1])
  mp.drawcoastlines()
  mp.drawstates()
  mp.drawcountries()
  #plt.clim()
  cbar=plt.colorbar()
  cbar.ax.tick_params(labelsize=14)
  if i== 0:
    plt.clim(0,1)
  elif i== 1:
    plt.clim(0,5)
    cbar.set_label('mm/3-hour', labelpad=-40, y=1.06, rotation=0,fontsize=14)
  elif i==2:
    plt.clim(0,2.5)
    cbar.set_label('mm/3-hour', labelpad=-40, y=1.06, rotation=0,fontsize=14)
  else: plt.clim(0,1)

  plt.tight_layout()
plt.show()


print(np.mean(cor_fig[2]))
print(np.mean(rmse_fig[2]))
print(np.mean(mae_fig[2]))

print(np.mean(pod_fig[2]))
print(np.mean(far_fig[2]))
print(np.mean(csi_fig[2]))

from mpl_toolkits.axes_grid1 import make_axes_locatable
#New figure 11/08/2023
display_list = [cor_fig, rmse_fig , mae_fig, pod_fig, far_fig, csi_fig]
title_y = ['CC', 'RMSE','MAE','POD', 'FAR','CSI']
title_x = ['PDIR-Now','U-Net','Efficient-UNet','cGAN']
# cor_fig[nan_indx1]=np.nan
# rmse_fig[nan_indx1]=np.nan
# mae_fig[nan_indx1]=np.nan
plt.figure(figsize=(8,14))
for i in range(6):
  for j in range(4):
    ax= plt.subplot(6, 4, i*4+j+1)

    im=mp.pcolor(x, y, display_list[i][j], cmap = 'jet')
    mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.2)#,fontsize=14,labels=[1,0,0,0])
    mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.2)#,fontsize=14,labels=[0,0,0,1])
    mp.drawcoastlines()
    mp.drawstates()
    mp.drawcountries()
    if i==1: plt.clim(0,5)
    elif i==2: plt.clim(0,2.5)
    else: plt.clim(0,1)
      # Add titles for rows
    if j == 0:
        plt.ylabel(title_y[i], rotation=90, labelpad=0.1, fontsize=12, fontweight='bold')
    # Add labels for columns
    if i == 0:
        plt.title(title_x[j], fontsize=12, fontweight='bold')
    if j == 3:
        divider = make_axes_locatable(ax)
        cax = divider.append_axes("right", size="5%", pad=0.1)
        cbar = plt.colorbar(im, cax=cax)
        if i==1 :
          cbar.set_label('mm/3-hour', rotation=90, labelpad=10, fontsize=10)
        elif i==2:
          cbar.set_label('mm/3-hour', rotation=90, labelpad=1, fontsize=10)
        # Add colorbar title
         # cbar.ax.set_title('mm/3hour', fontsize=8)
plt.tight_layout()
plt.show()

from mpl_toolkits.axes_grid1 import make_axes_locatable
#New figure 11/08/2023
display_list = [cor_fig, rmse_fig , mae_fig, pod_fig, far_fig, csi_fig]
title_y = ['CC', 'RMSE','MAE','POD', 'FAR','CSI']
title_x = ['PDIR-Now','U-Net','Efficient-UNet','cGAN']
# cor_fig[nan_indx1]=np.nan
# rmse_fig[nan_indx1]=np.nan
# mae_fig[nan_indx1]=np.nan
plt.figure(figsize=(14,9.5))
for i in range(4):
  for j in range(6):
    ax= plt.subplot(4, 6, i*6+j+1)

    im=mp.pcolor(x, y, display_list[j][i], cmap = 'jet')
    mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.2)#,fontsize=14,labels=[1,0,0,0])
    mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.2)#,fontsize=14,labels=[0,0,0,1])
    mp.drawcoastlines()
    mp.drawstates()
    mp.drawcountries()
    cbar=plt.colorbar()
      # Add titles for rows
    if j == 0:
        plt.ylabel(title_x[i], rotation=90, labelpad=0.1, fontsize=12, fontweight='bold')
    # Add labels for columns
    if i == 0:
        plt.title(title_y[j], fontsize=12, fontweight='bold')
    if j== 0:
      plt.clim(0,1)
    elif j== 1:
      plt.clim(0,5)
      cbar.set_label('mm/3-hour', labelpad=1, rotation=90,fontsize=10)
    elif j==2:
      plt.clim(0,2.5)
      cbar.set_label('mm/3-hour', labelpad=1, rotation=90,fontsize=10)
    else: plt.clim(0,1)
plt.tight_layout()
plt.show()

for i in range(Ytest.shape[0]):
  test1[i][nan_indx1]=np.nan
  test2[i][nan_indx1]=np.nan
  test3[i][nan_indx1]=np.nan
  Xtest[i][nan_indx1]=np.nan
  Ytest[i][nan_indx1]=np.nan
test1 = np.ma.masked_where(np.isnan(test1), test1)
test2 = np.ma.masked_where(np.isnan(test2), test2)
test3 = np.ma.masked_where(np.isnan(test3), test3)
Xtest = np.ma.masked_where(np.isnan(Xtest), Xtest)
Ytest = np.ma.masked_where(np.isnan(Ytest), Ytest)

#New figure
plt.figure(figsize=(12, 8))
for i in range(3):
  display_list = [Xtest[i+262][:,:,0], test1[i+262],test2[i+262],test3[i+262], Ytest[i+262]]
  title = ['PDIR-Now', 'U-Net','Efficient-UNet','cGAN', 'ST4']
  title_y =['1/2/2021 18:00','1/2/2021 21:00','1/3/2021 00:00']
  #plt.figure(figsize=(31,6))
  for j in range(5):
    plt.subplot(3, 5, i*5+j+1)
    if i==0:
      plt.title(title[j],fontsize=12,fontweight='bold')
    mp.pcolor(x, y, display_list[j], cmap = 'jet')
    mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.1)#,fontsize=14,labels=[1,0,0,0])
    mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.1)#,fontsize=14,labels=[0,0,0,1])
    mp.drawcoastlines()
    mp.drawstates()
    mp.drawcountries()
    #mp.drawlsmask(ocean_color='lightgrey', land_color=(0, 0, 0, 0), lakes=True, zorder = 2)
    plt.clim(0,4)
    if j == 0:
      plt.ylabel(title_y[i], rotation=90, labelpad=0.1, fontsize=12, fontweight='bold')
    if j==4:
      cbar = plt.colorbar()
      #cbar.ax.tick_params(labelsize=16)
      #cbar.set_label('mm/3-hour', labelpad=-40, y=1.08, rotation=0,fontsize=18)
      cbar.set_label('mm/3-hour', rotation=90, labelpad=1, fontsize=10)
  #plt.show()
plt.tight_layout()
plt.savefig('Figure 4', bbox_inches='tight', dpi=300)

#New 10/01/2023
for j in range(5):

  #title = ['Input Image', 'Unet','Efficient','GAN', 'Ground Truth']

  plt.figure(figsize=(32,5.2))
  for i in range(6):
    display_list = [Xtest[i+300][:,:,0], test1[i+300],test2[i+300],test3[i+300], Ytest[i+300]]
    plt.subplot(1, 6, i+1)
    #plt.title(title[j],fontsize=25)
    mp.pcolor(x, y, display_list[j], cmap = 'jet')
    mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.1)#,fontsize=14,labels=[1,0,0,0])
    mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.1)#,fontsize=14,labels=[0,0,0,1])
    mp.drawcoastlines()
    mp.drawstates()
    mp.drawcountries()
    #mp.drawlsmask(ocean_color='lightgrey', land_color=(0, 0, 0, 0), lakes=True, zorder = 2)
    plt.clim(0,4)

    if i==5:
      cbar = plt.colorbar()
      cbar.ax.tick_params(labelsize=16)
      cbar.set_label('mm/3-hour', labelpad=-40, y=1.08, rotation=0,fontsize=18)
    plt.axis('off')

  plt.show()

"""#Daily Analysis

"""

##
cm1=np.zeros([Ytest.shape[0],1])
cm2=np.zeros([Ytest.shape[0],1])
cm=np.zeros([Ytest.shape[0],1])

for i in range(Ytest.shape[0]):
  cm1[i] = np.sum(Xtest[i,:,:,0].flatten())- np.sum(Ytest[i].flatten())#/np.sum(Ytest[i].flatten())
  cm2[i] = np.sum(test3[i].flatten())- np.sum(Ytest[i].flatten())#/np.sum(Ytest[i].flatten())
  cm[i] = np.sum(Ytest[i].flatten())

print(np.mean(cm1))
print(np.mean(cm2))

##Accumulate 3hour to daily
test_day1=np.zeros([int(test1.shape[0]/8),256,256])
test_day2=np.zeros([int(test2.shape[0]/8),256,256])
test_day3=np.zeros([int(test3.shape[0]/8),256,256])
Xtest_day=np.zeros([int(test1.shape[0]/8),256,256])
Ytest_day=np.zeros([int(test1.shape[0]/8),256,256])
for i in range(int(test1.shape[0]/8)):
  test_day1[i]= sum(test1[i*8:i*8+8,:,:],0)
  test_day2[i]= sum(test2[i*8:i*8+8,:,:],0)
  test_day3[i]= sum(test3[i*8:i*8+8,:,:],0)
  Xtest_day[i]= sum(Xtest[i*8:i*8+8,:,:,0],0)
  Ytest_day[i]= sum(Ytest[i*8:i*8+8,:,:],0)

for i in range(Ytest_day.shape[0]):
  test_day1[i][nan_indx1]=np.nan
  test_day2[i][nan_indx1]=np.nan
  test_day3[i][nan_indx1]=np.nan
  Xtest_day[i][nan_indx1]=np.nan
  Ytest_day[i][nan_indx1]=np.nan
test_day1 = np.ma.masked_where(np.isnan(test_day1), test_day1)
test_day2 = np.ma.masked_where(np.isnan(test_day2), test_day2)
test_day3 = np.ma.masked_where(np.isnan(test_day3), test_day3)
Xtest_day = np.ma.masked_where(np.isnan(Xtest_day), Xtest_day)
Ytest_day = np.ma.masked_where(np.isnan(Ytest_day), Ytest_day)

print(np.mean(np.sum(Xtest_day,0)))
print(np.mean(np.sum(test_day1,0)))
print(np.mean(np.sum(test_day2,0)))
print(np.mean(np.sum(test_day3,0)))
print(np.mean(np.sum(Ytest_day,0)))

Xtest_day.shape

for i in range(10):
  display_list = [Xtest_day[i+13], test_day1[i+13],test_day2[i+13],test_day3[i+13], Ytest_day[i+13]]
  title = ['Input Image', 'Accum Unet','Accum Efficient','Accum GAN', 'Ground Truth']

  plt.figure(figsize=(28,4))
  for j in range(5):
    plt.subplot(1, 5, j+1)
    plt.title(title[j],fontsize=15)
    plt.imshow(display_list[j],cmap='jet')
    plt.clim(0,20)
    if j==4:
      plt.colorbar()


  plt.show()

for i in range(20):
  display_list = [Xtest_day[i+13], test_day1[i+13],test_day2[i+13],test_day3[i+13], Ytest_day[i+13]]
  title = ['Input Image', 'Accum Unet','Accum Efficient','Accum GAN', 'Ground Truth']

  plt.figure(figsize=(31,6))
  for j in range(5):
    plt.subplot(1, 5, j+1)
    plt.title(title[j],fontsize=25)
    mp.pcolor(x, y, display_list[j], cmap = 'jet')
    mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.1)#,fontsize=14,labels=[1,0,0,0])
    mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.1)#,fontsize=14,labels=[0,0,0,1])
    mp.drawcoastlines()
    mp.drawstates()
    mp.drawcountries()
    #mp.drawlsmask(ocean_color='lightgrey', land_color=(0, 0, 0, 0), lakes=True, zorder = 2)
    plt.clim(0,20)

    if j==4:
      cbar = plt.colorbar()
      cbar.ax.tick_params(labelsize=16)
      cbar.set_label('mm/day', labelpad=-40, y=1.08, rotation=0,fontsize=18)
    plt.axis('off')

  plt.show()

"""#Daily model"""

path = "/content/gdrive/MyDrive/Colab Notebooks/PDIR_Now/"
dir_list = os.listdir(path)
from tkinter import Tcl
dir_list=Tcl().call('lsort', '-dict', dir_list)
dir_list

path+ dir_list[11]

data3 = Dataset(path+ dir_list[10])
precip =data3.variables['precip'][:]
time = data3.variables['datetime'][:]
xtest1=np.zeros([365,384,384])
for i in range(365):
  xtest1[i]=precip[i][11:395,0:384]

data3 = Dataset(path+ dir_list[11])
precip =data3.variables['precip'][:]
time = data3.variables['datetime'][:]
xtest2=np.zeros([90,384,384])
for i in range(90):
  xtest2[i]=precip[i][11:395,0:384]

data3 = Dataset(r'/content/gdrive/MyDrive/Colab Notebooks/PDIR_Now/PDIR_United_States_2022-12-22121909pm_2021.nc')
precip =data3.variables['precip'][:]
time = data3.variables['datetime'][:]
xtest3=np.zeros([365,384,384])
for i in range(297):
    xtest3[i]=precip[i][11:395,0:384]
for i in range(298,365):
    xtest3[i]=precip[i-1][11:395,0:384]
#Missing data at index 297 for 2021
xtest3[297]= (xtest3[296]+xtest3[298])/2
lats = data3.variables['lat'][:]
lons = data3.variables['lon'][:]

xtest=np.concatenate([xtest1[365-31:365],xtest3[:59]])
xtest1,xtest2=[],[]
xtest.shape

path = "/content/gdrive/MyDrive/Colab Notebooks/ST4/"
dir_list = os.listdir(path)
from tkinter import Tcl
dir_list=Tcl().call('lsort', '-dict', dir_list)
dir_list

fn2= '/content/gdrive/MyDrive/Colab Notebooks/ST4/st4_daily_winter_21_22.mat'
mat = mat73.loadmat(fn2)['st4_daily']
ytest=np.zeros([mat.shape[2],384,384])
for i in range(mat.shape[2]):
    ytest[i]=mat[:,:,i]
ytest= ytest[31:31+90]
ytest.shape

fn2= '/content/gdrive/MyDrive/Colab Notebooks/ST4/ST4_2020_west.mat'
mat = io.loadmat(fn2)['st4_daily']
ytest1=np.zeros([365,384,384])
for i in range(365):
    ytest1[i]=mat[:,:,i]

fn2= '/content/gdrive/MyDrive/Colab Notebooks/ST4/ST4_2021_west.mat'
mat = io.loadmat(fn2)['st4_daily']
ytest2=np.zeros([365,384,384])
for i in range(365):
    ytest2[i]=mat[:,:,i]

ytest=np.concatenate([ytest1[365-31:365],ytest2[:59]])
ytest1,ytest2=[],[]
ytest.shape

select_id=[]
for i in range(ytest.shape[0]):
    if np.count_nonzero(np.isnan(ytest[i])) < 384*384:
        select_id.append(i)
len(select_id)

xtest=xtest[select_id]
ytest=ytest[select_id]

Xtest= np.zeros([xtest.shape[0],256,256,2])
Ytest= np.zeros([ytest.shape[0],256,256])
for i in range(xtest.shape[0]):
    a=xtest[i]
    b=ytest[i]
    idx=np.where(a==-99)
    a[idx]=-0.001
    b[np.where(np.isnan(b))]= 0
    b[idx]=-0.001
    a1=np.stack([a, dem],-1)
    Ytest[i]=b[:256,:256]
    Xtest[i]=a1[:256,:256,:]

#GAn daily prediction
BATCH_SIZE=1
Ytest = np.reshape(Ytest,[Ytest.shape[0], 256, 256,1])
test=np.concatenate((Xtest,Ytest), axis=-1)
def load(input):

  input_image = tf.convert_to_tensor(input[...,0:2])
  real_image = tf.convert_to_tensor(tf.reshape(input[...,2],[256,256,1]))

  # Convert both images to float32 tensors
  input_image = tf.cast(input_image, tf.float32)
  real_image = tf.cast(real_image, tf.float32)

  return input_image, real_image

## Build an input pipeline with `tf.data`
def load_image_train(image_file):
  input_image, real_image = load(image_file)

  return input_image, real_image

def load_image_test(image_file):
  input_image, real_image = load(image_file)
  return input_image, real_image

## Build an input pipeline with `tf.data`
test_dataset = tf.data.Dataset.from_tensor_slices(test)
test_dataset = test_dataset.map(load_image_test)
test_dataset = test_dataset.batch(BATCH_SIZE)
test=[]

test5=np.zeros([Xtest.shape[0],256,256])
i=0
for inp,tar in test_dataset:
  prediction = model_gan_daily(inp,training=True)
  test5[i]=np.array(prediction[0,...,0])
  i+=1

#Ef daily prediction
Ytest = np.reshape(Ytest,[Ytest.shape[0], 256, 256])
test4=model_daily.predict(Xtest,batch_size=4)
test4=test4.reshape(test4.shape[0],256,256).astype('float64')
nan_indx1 = np.where(Ytest[10]==-0.001)
count_indx1= len(nan_indx1[0])
count_indx1
#Adjust prediction
test4[np.where(test4<0)]=0
test5[np.where(test5<0)]=0
for i in range(Xtest.shape[0]):
  test4[i][nan_indx1]=-0.001
  test5[i][nan_indx1]=-0.001

# for i in range(test_day2.shape[0]):
#   test_day2[i][nan_indx1]=-0.001
#   test_day3[i][nan_indx1]=-0.001
#   Ytest_day[i][nan_indx1]=-0.001

for i in range(90):
  display_list = [Xtest[i][:,:,0], test_day3[i], test4[i],test5[i], Ytest[i]]
  title = ['Input Image', 'Accum GAN','Ef daily', 'GAN daily','Ground Truth']

  plt.figure(figsize=(28,4))
  for j in range(5):
    plt.subplot(1, 5, j+1)
    plt.title(title[j],fontsize=15)
    plt.imshow(display_list[j],cmap='jet')
    plt.clim(0,20)
    if j==4:
      plt.colorbar()


  plt.show()

cor_fig=np.zeros([256,256])
rmse_fig=np.zeros([256,256])
mae_fig=np.zeros([256,256])
for i in range(256):
  for j in range(256):
    if Ytest[1,i,j]==-0.001 :
      cor_fig[i,j]=np.nan;
      rmse_fig[i,j]=np.nan;
      mae_fig[i,j]=np.nan;
    else:
      cor_fig[i,j]=np.corrcoef(test4[:,i,j],Ytest[:,i,j])[1,0];
      rmse_fig[i,j] = np.sqrt(mean_squared_error(test4[:,i,j],Ytest[:,i,j]));
      mae_fig[i,j] = np.mean(np.abs(test4[:,i,j]-Ytest[:,i,j]))
  print(i)

cor_fig[nan_indx1]=np.nan
rmse_fig[nan_indx1]=np.nan
mae_fig[nan_indx1]=np.nan
cor_fig = np.ma.masked_where(np.isnan(cor_fig), cor_fig)
rmse_fig = np.ma.masked_where(np.isnan(rmse_fig), rmse_fig)
mae_fig = np.ma.masked_where(np.isnan(mae_fig), mae_fig)

display_list = [cor_fig, rmse_fig , mae_fig]
title = ['CC', 'RMSE','MAE']

plt.figure(figsize=(16,5))
for i in range(3):
  plt.subplot(1, 3, i+1)
  plt.title(title[i],fontsize=20)
  mp.pcolor(x, y, display_list[i], cmap = 'jet')
  mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.2)#,fontsize=14,labels=[1,0,0,0])
  mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.2)#,fontsize=14,labels=[0,0,0,1])
  mp.drawcoastlines()
  mp.drawstates()
  mp.drawcountries()
  plt.clim()

  cbar=plt.colorbar()
  cbar.ax.tick_params(labelsize=14)
  if i!= 0:
    cbar.set_label('mm/day', labelpad=-40, y=1.06, rotation=0,fontsize=14)
  plt.axis('off')
plt.show()

print(np.mean(cor_fig))
print(np.mean(rmse_fig))
print(np.mean(mae_fig))

###Spatial Analysis
for i in range(Ytest.shape[0]):
  test4[i][nan_indx1]=-0.001
  Xtest[i][nan_indx1]=-0.001
  Ytest[i][nan_indx1]=-0.001
from sklearn.metrics import confusion_matrix

a=test4.copy()
b=Ytest.copy()
c=Xtest[...,0].copy()
threshold =0.1

a[np.where(a<threshold)]= 0
a[np.where(a>=threshold)]=1
b[np.where(b<threshold)]=0
b[np.where(b>=threshold)]=1
c[np.where(c<threshold)]=0
c[np.where(c>=threshold)]=1

def matrix(a,b):
  m=confusion_matrix(b,a,labels=[True, False])
  return m

pod_fig=np.zeros([256,256])
far_fig=np.zeros([256,256])
csi_fig=np.zeros([256,256])


for i in range(256):
  for j in range(256):
    m=matrix(a[:,i,j],b[:,i,j]);
    if Ytest_day[1,i,j]==-0.001 or np.sum(m[0,:])==0 or np.sum(m[:,0])==0:
      pod_fig[i,j]=np.nan;
      far_fig[i,j]=np.nan;
      csi_fig[i,j]=np.nan;
    else:
      pod_fig[i,j]=m[0,0]/np.sum(m[0,:]);
      far_fig[i,j]=m[1,0]/np.sum(m[:,0]);
      csi_fig[i,j]=m[0,0]/(np.sum(m[0,:])+m[1,0]);
  print(i)

pod_fig[nan_indx1]=np.nan
far_fig[nan_indx1]=np.nan
csi_fig[nan_indx1]=np.nan
pod_fig = np.ma.masked_where(np.isnan(pod_fig), pod_fig)
far_fig = np.ma.masked_where(np.isnan(far_fig), far_fig)
csi_fig = np.ma.masked_where(np.isnan(csi_fig), csi_fig)

display_list = [pod_fig, far_fig, csi_fig]
title = ['POD', 'FAR','CSI']
plt.figure(figsize=(16,5))
for i in range(3):
  plt.subplot(1, 3, i+1)
  plt.title(title[i],fontsize=20)
  mp.pcolor(x, y, display_list[i], cmap = 'jet')
  mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.2)#,fontsize=14,labels=[1,0,0,0])
  mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.2)#,fontsize=14,labels=[0,0,0,1])
  mp.drawcoastlines()
  mp.drawstates()
  mp.drawcountries()
  plt.clim()
  plt.colorbar()
  cbar.ax.tick_params(labelsize=14)
  plt.axis('off')
plt.show()

print(np.mean(pod_fig))
print(np.mean(far_fig))
print(np.mean(csi_fig))

#New figure 09/28/2023
display_list = [cor_fig, rmse_fig , mae_fig, pod_fig, far_fig, csi_fig]
title = ['CC', 'RMSE','MAE','POD', 'FAR','CSI']
cor_fig[nan_indx1]=np.nan
rmse_fig[nan_indx1]=np.nan
mae_fig[nan_indx1]=np.nan
plt.figure(figsize=(32,5))
for i in range(6):
  plt.subplot(1, 6, i+1)
  #plt.title(title[i],fontsize=24)
  mp.pcolor(x, y, display_list[i], cmap = 'jet')
  mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.2)#,fontsize=14,labels=[1,0,0,0])
  mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.2)#,fontsize=14,labels=[0,0,0,1])
  mp.drawcoastlines()
  mp.drawstates()
  mp.drawcountries()
  #plt.clim()
  cbar=plt.colorbar()
  cbar.ax.tick_params(labelsize=14)
  if i== 0:
    plt.clim(0,1)
  elif i== 1:
    plt.clim(0,20)
    cbar.set_label('mm/day', labelpad=-40, y=1.06, rotation=0,fontsize=14)
  elif i==2:
    plt.clim(0,20)
    cbar.set_label('mm/day', labelpad=-40, y=1.06, rotation=0,fontsize=14)
  else: plt.clim(0,1)
plt.show()

cor_fig = np.ma.masked_where(np.isnan(cor_fig), cor_fig)
rmse_fig = np.ma.masked_where(np.isnan(rmse_fig), rmse_fig)
mae_fig = np.ma.masked_where(np.isnan(mae_fig), mae_fig)

print(np.mean(cor_fig))
print(np.mean(rmse_fig))
print(np.mean(mae_fig))

#New figure 11/08/2023
def matrix(a, b):
  m = np.zeros((2, 2), dtype=np.int64)
  m[0, 0] = np.sum(np.logical_and(a == 1, b == 1))
  m[1, 1] = np.sum(np.logical_and(a == 0, b == 0))
  m[0, 1] = np.sum(np.logical_and(a == 0, b == 1))
  m[1, 0] = np.sum(np.logical_and(a == 1, b == 0))
  return m
##
for i in range(Ytest.shape[0]):
  Xtest[i][nan_indx1]=-0.001
  Ytest[i][nan_indx1]=-0.001
#
cor_fig, rmse_fig , mae_fig, pod_fig, far_fig, csi_fig = np.empty([5,256,256]),np.empty([5,256,256]),np.empty([5,256,256]),np.empty([5,256,256]),np.empty([5,256,256]),np.empty([5,256,256])
a=np.empty((90,256,256), dtype=np.uint8)
b=np.empty((90,256,256), dtype=np.uint8)
c=np.empty((90,256,256), dtype=np.uint8)
list1=[Xtest[...,0], test_day2, test_day3, test4, test5]
##
for l in range(5):
  pred=list1[l]
  threshold =0.1
  a = np.where(pred < threshold, 0, 1)
  b = np.where(Ytest < threshold, 0, 1)
  for i in range(256):
    for j in range(256):
      if Ytest[1,i,j]==-0.001 :
        cor_fig[l,i,j]=np.nan;
        rmse_fig[l,i,j]=np.nan;
        mae_fig[l,i,j]=np.nan;
      else:
        cor_fig[l,i,j]=np.corrcoef(pred[:,i,j],Ytest[:,i,j])[1,0];
        rmse_fig[l,i,j] = np.sqrt(mean_squared_error(pred[:,i,j],Ytest[:,i,j]));
        mae_fig[l,i,j] = np.mean(np.abs(pred[:,i,j]-Ytest[:,i,j]))
    ##
      m=matrix(a[:,i,j],b[:,i,j]);
      if Ytest[1,i,j]==-0.001 or np.sum(m[0,:])==0 or np.sum(m[:,0])==0:
        pod_fig[l,i,j]=np.nan;
        far_fig[l,i,j]=np.nan;
        csi_fig[l,i,j]=np.nan;
      else:
        pod_fig[l,i,j]=m[0,0]/np.sum(m[0,:]);
        far_fig[l,i,j]=m[1,0]/np.sum(m[:,0]);
        csi_fig[l,i,j]=m[0,0]/(np.sum(m[0,:])+m[1,0])
  print(l)

from mpl_toolkits.axes_grid1 import make_axes_locatable
#New figure 11/08/2023
display_list = [cor_fig, rmse_fig , mae_fig, pod_fig, far_fig, csi_fig]
title_y = ['CC', 'RMSE','MAE','POD', 'FAR','CSI']
title_x = ['PDIR-Now\n(Daily)', 'Efficient-UNet\n(Cummulative 3hourly)','cGAN\n(Cummulative 3hourly)','Efficient-UNet\n(Daily)','cGAN\n(Daily)', 'ST4\n(Daily)']

# cor_fig[nan_indx1]=np.nan
# rmse_fig[nan_indx1]=np.nan
# mae_fig[nan_indx1]=np.nan
plt.figure(figsize=(11,14))
for i in range(6):
  for j in range(5):
    ax= plt.subplot(6, 5, i*5+j+1)

    im=mp.pcolor(x, y, display_list[i][j], cmap = 'jet')
    mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.2)#,fontsize=14,labels=[1,0,0,0])
    mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.2)#,fontsize=14,labels=[0,0,0,1])
    mp.drawcoastlines()
    mp.drawstates()
    mp.drawcountries()
    if i==1: plt.clim(0,20)
    elif i==2: plt.clim(0,20)
    else: plt.clim(0,1)
      # Add titles for rows
    if j == 0:
        plt.ylabel(title_y[i], rotation=90, labelpad=0.1, fontsize=12, fontweight='bold')
    # Add labels for columns
    if i == 0:
        plt.title(title_x[j], fontsize=11, fontweight='bold')
    if j == 4:
        divider = make_axes_locatable(ax)
        cax = divider.append_axes("right", size="5%", pad=0.1)
        cbar = plt.colorbar(im, cax=cax)
        if i==1 :
          cbar.set_label('mm/day', rotation=90, labelpad=1, fontsize=10)
        elif i==2:
          cbar.set_label('mm/day', rotation=90, labelpad=1, fontsize=10)
        # Add colorbar title
         # cbar.ax.set_title('mm/3hour', fontsize=8)
plt.tight_layout()
plt.show()

from mpl_toolkits.axes_grid1 import make_axes_locatable
#New figure 11/08/2023
display_list = [cor_fig, rmse_fig , mae_fig, pod_fig, far_fig, csi_fig]
title_y = ['CC', 'RMSE','MAE','POD', 'FAR','CSI']
title_x = ['PDIR-Now\n(Daily)', 'Efficient-UNet\n(Cummulative 3hourly)','cGAN\n(Cummulative 3hourly)','Efficient-UNet\n(Daily)','cGAN\n(Daily)', 'ST4\n(Daily)']
# cor_fig[nan_indx1]=np.nan
# rmse_fig[nan_indx1]=np.nan
# mae_fig[nan_indx1]=np.nan
plt.figure(figsize=(14,12))
for i in range(5):
  for j in range(6):
    ax= plt.subplot(5, 6, i*6+j+1)

    im=mp.pcolor(x, y, display_list[j][i], cmap = 'jet')
    mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.2)#,fontsize=14,labels=[1,0,0,0])
    mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.2)#,fontsize=14,labels=[0,0,0,1])
    mp.drawcoastlines()
    mp.drawstates()
    mp.drawcountries()
    cbar=plt.colorbar()
      # Add titles for rows
    if j == 0:
        plt.ylabel(title_x[i], rotation=90, labelpad=0.1, fontsize=11, fontweight='bold')
    # Add labels for columns
    if i == 0:
        plt.title(title_y[j], fontsize=12, fontweight='bold')
    if j== 0:
      plt.clim(0,1)
    elif j== 1:
      plt.clim(0,20)
      cbar.set_label('mm/day', labelpad=1, rotation=90,fontsize=10)
    elif j==2:
      plt.clim(0,20)
      cbar.set_label('mm/day', labelpad=1, rotation=90,fontsize=10)
    else: plt.clim(0,1)
plt.tight_layout()
plt.show()

for i in range(Ytest.shape[0]):
  test4[i][nan_indx1]=np.nan
  test5[i][nan_indx1]=np.nan
  Xtest[i][nan_indx1]=np.nan
  Ytest[i][nan_indx1]=np.nan
test4 = np.ma.masked_where(np.isnan(test4), test4)
test5 = np.ma.masked_where(np.isnan(test5), test5)
Xtest = np.ma.masked_where(np.isnan(Xtest), Xtest)
Ytest = np.ma.masked_where(np.isnan(Ytest), Ytest)

for i in range(70):
  display_list = [Xtest[i+12,...,0],test_day3[i+12], test4[i+12],test5[i+12], Ytest[i+12]]
  title = ['Input Image','Accum GAN','Ef daily', 'GAN daily','Ground Truth']

  plt.figure(figsize=(31,6))
  for j in range(5):
    plt.subplot(1, 5, j+1)
    plt.title(title[j],fontsize=25)
    mp.pcolor(x, y, display_list[j], cmap = 'jet')
    mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.1)#,fontsize=14,labels=[1,0,0,0])
    mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.1)#,fontsize=14,labels=[0,0,0,1])
    mp.drawcoastlines()
    mp.drawstates()
    mp.drawcountries()
    #mp.drawlsmask(ocean_color='lightgrey', land_color=(0, 0, 0, 0), lakes=True, zorder = 2)
    plt.clim(0,20)

    if j==4:
      cbar = plt.colorbar()
      cbar.ax.tick_params(labelsize=16)
      cbar.set_label('mm/day', labelpad=-40, y=1.08, rotation=0,fontsize=18)
    plt.axis('off')

  plt.show()

#New figure 10/01/2023
plt.figure(figsize=(14, 8))
for i in range(3):
  display_list = [Xtest[i+32][:,:,0], test_day2[i+32],test_day3[i+32],test4[i+32],test5[i+32], Ytest[i+32]]
  title = ['PDIR-Now\n(Daily)', 'Efficient-UNet\n(Cummulative 3hourly)','cGAN\n(Cummulative 3hourly)','Efficient-UNet\n(Daily)','cGAN\n(Daily)', 'ST4\n(Daily)']
  title_y = ['1/2/2021','1/3/2021','1/4/2021']
  for j in range(6):
    plt.subplot(3, 6, i*6+j+1)
    if i==0:
      plt.title(title[j],fontsize=12, fontweight='bold')
    mp.pcolor(x, y, display_list[j], cmap = 'jet')
    mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.1)#,fontsize=14,labels=[1,0,0,0])
    mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.1)#,fontsize=14,labels=[0,0,0,1])
    mp.drawcoastlines()
    mp.drawstates()
    mp.drawcountries()
    #mp.drawlsmask(ocean_color='lightgrey', land_color=(0, 0, 0, 0), lakes=True, zorder = 2)
    plt.clim(0,20)

    if j == 0:
      plt.ylabel(title_y[i], rotation=90, labelpad=0.1, fontsize=12, fontweight='bold')
    if j==5:
      cbar = plt.colorbar()
      #cbar.ax.tick_params(labelsize=16)
      #cbar.set_label('mm/3-hour', labelpad=-40, y=1.08, rotation=0,fontsize=18)
      cbar.set_label('mm/day', rotation=90, labelpad=1, fontsize=10)

  #plt.show()
plt.tight_layout()
plt.savefig('Figure 6', bbox_inches='tight', dpi=300)

values = np.array([[np.mean(np.sum(Xtest[:31,...,0],axis=0)), np.mean(np.sum(test4[:31],axis=0)),np.mean(np.sum(test5[:31],axis=0)), np.mean(np.sum(Ytest[:31],axis=0))], [np.mean(np.sum(Xtest[31:62,...,0],axis=0)), np.mean(np.sum(test4[31:62],axis=0)),np.mean(np.sum(test5[31:62],axis=0)), np.mean(np.sum(Ytest[31:62],axis=0))],[np.mean(np.sum(Xtest[62:,...,0],axis=0)), np.mean(np.sum(test4[62:],axis=0)),np.mean(np.sum(test5[62:],axis=0)), np.mean(np.sum(Ytest[62:],axis=0))]])
values[:,1]=[58.80,74.2,50.82]
print(values)

display_list = np.array([[np.sum(Xtest[:31,...,0],axis=0), np.sum(test4[:31],axis=0),np.sum(test5[:31],axis=0), np.sum(Ytest[:31],axis=0)], [np.sum(Xtest[31:62,...,0],axis=0), np.sum(test4[31:62],axis=0),np.sum(test5[31:62],axis=0), np.sum(Ytest[31:62],axis=0)],[np.sum(Xtest[62:,...,0],axis=0), np.sum(test4[62:],axis=0),np.sum(test5[62:],axis=0), np.sum(Ytest[62:],axis=0)]])
title = ['PDIR-Now', 'Efficient-UNet','cGAN', 'ST4']
title_y =['December','January','February']
plt.figure(figsize=(12,10))
for j in range(3):
  for i in range(4):
    tmp=display_list[j,i]
    tmp[nan_indx1]=np.nan
    tmp = np.ma.masked_where(np.isnan(tmp), tmp)
    plt.subplot(3, 4, j*4+i+1)
    #plt.title(title[i],fontsize=25)
    mp.pcolor(x, y, tmp, cmap = 'jet')
    mp.drawparallels(np.arange(lats[255],lats[0],2), linewidth=0.2)#,fontsize=14,labels=[1,0,0,0])
    mp.drawmeridians(np.arange(lons[0],lons[255],3), linewidth=0.2)#,fontsize=14,labels=[0,0,0,1])
    mp.drawcoastlines()
    mp.drawstates()
    mp.drawcountries()
    plt.clim(0,400)
    ax = plt.gca()
    plt.text(0.95,0.05, f'{values[j,i]:.2f}', fontsize=13, fontweight='bold', color='white', transform=ax.transAxes,
         horizontalalignment='right', verticalalignment='bottom')
    if j==0:
      plt.title(title[i],fontsize=12, fontweight='bold')
    if i==0:
      plt.ylabel(title_y[j], rotation=90, labelpad=0.1, fontsize=12, fontweight='bold')
    if i==3:
      cbar = plt.colorbar()
      cbar.ax.tick_params()
      cbar.set_label('mm/month', labelpad=1, rotation=90,fontsize=11)
      plt.clim(0,400)

plt.tight_layout()
plt.show()

display_list[0,3]

print([np.mean(np.sum(Xtest[:31,...,0],axis=0)), np.mean(np.sum(test4[:31],axis=0)),np.mean(np.sum(test5[:31],axis=0)), np.mean(np.sum(Ytest[:31],axis=0))])
print([np.mean(np.sum(Xtest[31:62,...,0],axis=0)), np.mean(np.sum(test4[31:62],axis=0)),np.mean(np.sum(test5[31:62],axis=0)), np.mean(np.sum(Ytest[31:62],axis=0))])
print([np.mean(np.sum(Xtest[62:,...,0],axis=0)), np.mean(np.sum(test4[62:],axis=0)),np.mean(np.sum(test5[62:],axis=0)), np.mean(np.sum(Ytest[62:],axis=0))])

cor_fig=np.corrcoef(np.sum(Xtest[62:,...,0],axis=0),np.sum(Ytest[62:],axis=0))[1,0];
rmse_fig = np.sqrt(mean_squared_error(np.sum(Xtest[62:,...,0],axis=0),np.sum(Ytest[62:],axis=0)));
mae_fig= np.mean(np.abs(np.sum(Xtest[62:,...,0],axis=0)-np.sum(Ytest[62:],axis=0)))


# cor_fig[nan_indx1]=np.nan
# rmse_fig[nan_indx1]=np.nan
# mae_fig[nan_indx1]=np.nan
print(np.mean(cor_fig))
print(np.mean(rmse_fig))
print(np.mean(mae_fig))

#PDIR-NOW
0.8989157019184458
48.73520696968456
31.76437001463744

0.964990357512026
82.33758178500244
54.497269378155686

0.9618818802436343
74.43278263169967
42.3753272042498
#EF
0.9621346908140141
63.43705548853271
34.92156908526675

0.974080955221853
63.760830632052944
38.52180039348952

0.9761880173146469
87.06267508278944
49.3511090546894
#GAN
0.9804186869941247
22.778112078126544
13.7863349177548

0.9898658335372092
36.547921926229925
24.277048519552228

0.9879832710022235
72.90976226955921
40.320309374837066

"""#Time series"""

series= np.zeros((6,90))

for i in range(90):
  series[0,i]= np.sum(Xtest[i])/256/256
  series[1,i]= np.sum(test_day2[i])/256/256
  series[2,i]= np.sum(test_day3[i])/256/256
  series[3,i]= np.sum(test4[i])/256/256
  series[4,i]= np.sum(test5[i])/256/256
  series[5,i]= np.sum(Ytest[i])/256/256

for i in range(5):
  print(np.mean(np.abs(series[i]-series[5])))
# for i in range(5):
#   nse = 1 - np.sum((series[i]-series[5])**2)/np.sum((series[i] -np.mean(series[i]))**2)
#   print(nse)
for i in range(5):
  print(np.corrcoef(series[i],series[5])[1,0])
for i in range(5):
  print(np.sqrt(np.mean((series[i]-series[5])**2)))

np.sum(series,1)

fig, ax = plt.subplots(figsize=(20,10))
name=['PDIR-Now(Daily)', 'Efficient-UNet\n(Cummulative 3hourly)','cGAN\n(Cummulative 3hourly)','Efficient-UNet(Daily)','cGAN(Daily)', 'ST4(Daily)']
# Plot each time series


ax.plot(series[0],linewidth=2, label=name[0],color= 'black', linestyle='--')
ax.plot(series[1], label=name[1] , color= 'lightgrey')
ax.plot(series[2], label=name[2] , color= 'grey')
ax.plot(series[3],linewidth=2, label=name[3],color= 'blue')
ax.plot(series[4],linewidth=2, label=name[4],color= 'red')
ax.plot(series[5],linewidth=0.5)
ax.fill_between(np.arange(len(series[5])), series[5], color='lightblue', alpha=0.3,label='ST4(Daily)')

#plt.xlabel('Day')
plt.ylabel('Precipitation (mm/day)',fontsize=15)
#plt.title('Winter 2020-2021')
ax.legend(fontsize=15)
ax.set_xlim(0,89)
ax.set_ylim(0,20)
#ax.grid(True)
plt.grid(linestyle='--',alpha=0.3)

xticks = np.arange(0, 90)
xtick_labels = ['Dec 1,2020', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
                '', '', '', '', '', '', '', '', 'Jan 1,2021', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
                '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'Feb 1, 2021', '', '', '', '', '', '', '', '',
                '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '','Feb 28,2021']
plt.xticks(xticks, xtick_labels, rotation='horizontal',fontsize=15)
plt.show()

len(xtick_labels)

"""#CDF"""

data1 = Xtest.flatten()
data2 = Ytest.flatten()
data3 = test4.flatten()
data4 = test5.flatten()
# compute the sorted data and its CDF using the `numpy.sort` and `numpy.cumsum` functions
sorted_data1 = np.sort(data1)
cdf1 = np.cumsum(sorted_data1) / float(len(sorted_data1))
sorted_data2 = np.sort(data2)
cdf2 = np.cumsum(sorted_data2) / float(len(sorted_data2))
sorted_data3 = np.sort(data3)
cdf3 = np.cumsum(sorted_data3) / float(len(sorted_data3))
sorted_data4 = np.sort(data4)
cdf4 = np.cumsum(sorted_data4) / float(len(sorted_data4))
# normalize the CDFs
cdf1 = cdf1 / np.max(cdf1)
cdf2 = cdf2 / np.max(cdf2)
cdf3 = cdf3 / np.max(cdf3)
cdf4 = cdf4 / np.max(cdf4)
# plot the CDFs using the `matplotlib.pyplot.plot` function
fig, ax = plt.subplots(figsize=(15,10))
plt.plot(sorted_data1, cdf1, label='PDIR')
plt.plot(sorted_data2, cdf2, label='ST4')
plt.plot(sorted_data3, cdf3, label='EF daily')
plt.plot(sorted_data4, cdf4, label='GAN daily')
# set the axis labels and title
plt.xlabel('Precip (mm/day)')
plt.ylabel('CDF')
plt.title('')
plt.xlim(0,200)
plt.ylim(0,1)
plt.legend()
plt.grid()
plt.show()

"""#Log

Test 03/21/2023

Test 04/05/2023
"""

##3hourly:
#PDIR:
0.2614991898224234
1.6045808307486602
0.7438147709180309

0.6971008372961502
0.726003970313722
0.2434268723340019

#Model:
#Orginal Unet
0.3084733992979219
1.0434783220878583
0.5258179276030001

0.8241424161840788
0.7826435922138353
0.20270813312585495


#GAN
0.36890365229377836
0.9783018447802831
0.39477500373247393

0.46164391814587497
0.5844818523021614
0.28178160917806067


#Efficient
0.4095790089705213
0.9579301147257314
0.40053506101805353

0.6740259486047396
0.6637448652023569
0.2840791199932215


#DAILY
#CC, RMSE, MAE , POD, FAR, CSI
#PDIR:
0.4439403966196868
6.048393409160428
3.5743700836068677

0.9472193523897583
0.5795348703214214
0.4130764210448705

#Accum Efficien-net
0.6162015679218752
4.248649648941974
2.44799043367734

0.9953103608916234
0.629464567879916
0.36997547224910504

#Accum GAN
0.617083270192191
3.859140067129275
2.1787959886785897

0.7626547257861434
0.45977563124449955
0.46131175692521414

#Daily Efficient Model:
0.656656038173428
4.045857498065171
2.1200375771129316

0.8207839954031438
0.4600206111409078
0.4726430728959523

#Daily GAN Model:
0.6069030226584884
3.8560459947543793
2.063333811445269

0.6909926771285354
0.42304105990147123
0.46918653989422276

"""Log 4/14/2023 test 3hourly winter 12-2"""

##3hourly: 2020-2021
#PDIR:
0.2281931085872202
1.4374519787600744
0.6603756368472316

0.6527887628153537
0.7044241836476672
0.2507029225913735

#Unet
0.27776702977958345
0.9830359338844517
0.49308868992333654

0.8075630239001131
0.762193784453725
0.21791013313093888

#EF
0.3545782170461347
0.9399254415195831
0.3911228368308213

0.6282442808493895
0.6407432139042906
0.29251907869683413

#GAN
0.3358320086620163
0.9579890439170713
0.3464952496258759

0.4020831425758474
0.5754367830149623
0.2583271967168894

###########################################Daily: 2020-2021
#PDIR
0.40711378009016314
6.087238645618923
4.002198599484309

0.9584283006235884
0.5516435076691133
0.4390223526856107

#Accum Efficien-net
0.5298274418902698
4.2724587574526955
2.3585619795001254

0.9942970356335555
0.6017489433441231
0.3974579407394544

#Accum GAN
0.5132998222125699
4.161830233878456
2.2220249728167567

0.7218948871386687
0.4143763566641806
0.4775983175743061

#EF daily
0.5414312526774491
4.257172097118568
2.104494815629814

0.7974492826889044
0.44760378796501193
0.477695288977269


#GAN daily
0.6088069784719407
3.699075552182835
1.7576775590061775

0.6984044942994919
0.33764651505716825
0.5260049001481067

"""Log 4/17/2023 test winter 2021-2022"""

##3hourly: 2021-2022
#PDIR:
0.21377141804886746
1.2828509506842607
0.5665714801627113

0.668266928642114
0.694897040897149
0.2601320721442375
#Unet


#EF
0.33975652344198143
0.9563380107137169
0.3687540757320507

0.6574848797683556
0.6457138703829742
0.28903110398142756
#GAN

0.30772077877620624
0.9891473607093799
0.3599327722719025

0.4546390141033875
0.5538458420701153
0.28656024806259744

###########################################Daily: 2021-2022
#PDIR
0.4172021459576603
6.016889028964992
3.544863822508758

0.9664738715614013
0.5797631164097384
0.41284672569167075

#Accum Efficien-net
0.6025168612154221
4.615255645861514
2.222159159229117

0.9954835454912158
0.6543760918282892
0.34497199308434046

#Accum GAN
0.5359147144139005
4.483951071480622
2.0540091452479285

0.762512224666415
0.4320601984246402
0.4764541934237395

#EF daily
0.5183249061389547
4.812541553028041
2.085610095244683

0.7820422795824387
0.44621560448225395
0.4642761963552863

#GAN daily
0.554201827678957
4.726164447554373
2.0484286107135

0.6967617483713041
0.35261337667770104
0.5073679344924371

"""Log 4/18/2023 test winter 2022-2023"""

##3hourly: 2022-2023
#PDIR:
0.24724374589956355
1.582160268796704
0.7267766002181817
#Unet


#EF
0.32993764876367815
1.1034459676130095
0.4392567777414671

#GAN


###########################################Daily: 2021-2022
#PDIR


#Accum Efficien-net

#Accum GAN

#EF daily


#GAN daily
